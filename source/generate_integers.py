# -*- coding: utf-8 -*-
"""
Python code for generating the sequence of integers generated by a sequence of primes.
"""

def AddToSortedList(x, sl):
    i = 0
    while i < len(sl) and x > sl[i]:
        i += 1
    sl.insert(i, x)

class IntegersGenerator:
    # The primes are expected to be in order
    def __init__(self, primes):
        # The index of the last multiple. This is an optimization.
        self.last_index = 0
        # Another optimization
        self.last_prime_index = 0
        self.primes = primes
        # two lists of size N(last prime)
        self.integers = [1]
        self.isprime = [False]
        for i in range(0,len(primes)):
            if primes[i] in self.integers:
                print("ERROR: %f is already in the list", primes[i])
                break
            else:
                # print("current prime is {}".format(primes[i]))
                # integers[j] gives the number we multiply times primes[i]
                j = 0
                self.last_index = self.last_prime_index
                while True:
                    if primes[i]*self.integers[j] <= primes[len(primes)-1]:
                        # print(primes[i]*self.integers[j])
                        self.AddToIntegers(primes[i]*self.integers[j],
                                           j == 0)
                        j += 1
                    else:
                        break
    
    def AddToIntegers(self, x, xIsPrime):
        while (self.last_index < len(self.integers) and
               x > self.integers[self.last_index]):
            self.last_index += 1
        self.integers.insert(self.last_index, x)
        self.isprime.insert(self.last_index, xIsPrime)
        if xIsPrime:
            self.last_prime_index = self.last_index
        
    def NumberIntegers(self):
        return len(self.integers)
        
    def GetPrimeBoolList(self):
        return self.isprime

class SieveMultiply:
    # The primes are expected to be in order
    def __init__(self, primes):
        self.primes = primes
        # Interval is equal to the product of the primes
        self.interval = 1
        for prime in primes:
            self.interval *= prime
        # interval is equal to the sum of the elements in partitions
        # len(partitions) is equal to Euler's Totient/Phi of interval
        self.partitions = [1]
        u = 0
        for n in range(2, self.interval+1):
            if self.DivisibleByPrimes(n):
                self.partitions[u] += 1
            else:
                u += 1
                self.partitions.append(1)
        
    def DivisibleByPrimes(self, n):
        for prime in self.primes:
            if n % prime == 0:
                return True
        return False
    
    def uTn(self, u):
        n = 0
        if u > 1:
            u -= 1
            n += 1
            x = self.interval
            if u >= len(self.partitions):
                n += + x * int(u / len(self.partitions))
                u -= len(self.partitions) * int(u / len(self.partitions))
            for i in range(0, u):
                n += self.partitions[i]
        else:
            n = 1
        return n

    def nTu(self, n):
        u = 0
        if n > 1:
            n -= 1
            u += 1
            x = self.interval
            if n >= x:
                u += len(self.partitions) * int(n / x)
                n -= x * int(n / x)
            for i in range(0, len(self.partitions)):
                n -= self.partitions[i]
                if n < 0:
                    break
                u += 1
        else:
            u = 1
        return u
        
    def multiply(self, x, y):
        return self.nTu(self.uTn(x)*self.uTn(y))