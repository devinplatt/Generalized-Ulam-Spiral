# -*- coding: utf-8 -*-
"""
Python code for generating the sequence of integers generated by a sequence of primes.
"""

def AddToSortedList(x, sl):
	i = 0
	while i < len(sl) and x > sl[i]:
		i += 1
	sl.insert(i, x)

class IntegersGenerator:
	# The primes are expected to be in order
	def __init__(self, primes):
		self.primes = primes
		# two lists of size N(last prime)
		self.integers = [1]
		self.isprime = [False]
		for i in range(0,len(primes)):
			if primes[i] in self.integers:
				print("ERROR: %f is already in the list", primes[i])
				break
			else:
				# print("current prime is {}".format(primes[i]))
				j = 0
				while True:
					if primes[i]*self.integers[j] <= primes[len(primes)-1]:
						# print(primes[i]*self.integers[j])
						self.AddToIntegers(primes[i]*self.integers[j],
										   j == 0)
						j += 1
					else:
						break
	
	def AddToIntegers(self, x, xIsPrime):
		i = 0
		while i < len(self.integers) and x > self.integers[i]:
			i += 1
		self.integers.insert(i, x)
		self.isprime.insert(i, xIsPrime)
		
	def NumberIntegers(self):
		return len(self.integers)
		
	def GetPrimeBoolList(self):
		return self.isprime
		
# ig = IntegersGenerator([2,3,5,7,11,13,17,19,23,29,31])

# print("Integers")
# for x in ig.integers:
# 	print(x)
	
# for index, value in enumerate(ig.isprime):
#	if value == True:
#		print(index+1)


class SieveMultiply:
	# The primes are expected to be in order
	def __init__(self, primes):
		self.primes = primes
		# Interval is equal to the product of the primes
		self.interval = 1
		for prime in primes:
			self.interval *= prime
		# interval is equal to the sum of the elements in partitions
		# len(partitions) is equal to Euler's Totient/Phi of interval
		self.partitions = [1]
		u = 0
		for n in range(2, self.interval+1):
			if self.DivisibleByPrimes(n):
				self.partitions[u] += 1
			else:
				u += 1
				self.partitions.append(1)
		
	def DivisibleByPrimes(self, n):
		for prime in self.primes:
			if n % prime == 0:
				return True
		return False
	
	def uTn(self, u):
		n = 0
		if u > 1:
			u -= 1
			n += 1
			x = self.interval
			if u >= len(self.partitions):
				n += + x * int(u / len(self.partitions))
				u -= len(self.partitions) * int(u / len(self.partitions))
			for i in range(0, u):
				n += self.partitions[i]
		else:
			n = 1
		return n

	def nTu(self, n):
		u = 0
		if n > 1:
			n -= 1
			u += 1
			x = self.interval
			if n >= x:
				u += len(self.partitions) * int(n / x)
				n -= x * int(n / x)
			for i in range(0, len(self.partitions)):
				n -= self.partitions[i]
				if n < 0:
					break
				u += 1
		else:
			u = 1
		return u
		
	def multiply(self, x, y):
		return self.nTu(self.uTn(x)*self.uTn(y))
	
# Tests	
#sm = SieveMultiply([2,3])
#for part in sm.partitions:
#	print(part)
#print(sm.uTn(1))
#print(sm.uTn(2))
#print(sm.uTn(3))
#print(sm.uTn(4))
#print(sm.uTn(5))
#print("nTu")
#print(sm.nTu(1))
#print(sm.nTu(5))
#print(sm.nTu(7))
#print(sm.nTu(11))
#print(sm.nTu(13))
#print(sm.nTu(17))
#print("multiply")
#print(sm.multiply(2,2)) # 9
#print(sm.multiply(2,3)) # 12